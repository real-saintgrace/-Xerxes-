--// References  
-- [ Bodyparts ] : https://create.roblox.com/docs/reference/engine/enums/BodyPartR15  
-- [ EasingStyles ] : https://create.roblox.com/docs/reference/engine/enums/EasingStyle  

getgenv().Camlock = {
    ["Enable"] = true, 
    ["Keybind"] = Enum.KeyCode.Q, -- Press this key to toggle camlock (You can change it)
    ["AimPart"] = "HumanoidRootPart", -- The body part to lock onto, you can see the body parts link to see what you would like to lock on
    ["Prediction"] = 0.146, -- calculate for target aim precision
    ["UseSmoothness"] = true, -- If true, makes aiming smooth; if false, locks instantly
    ["SmoothnessValue"] = 0.012, -- Controls how smooth the aim moves
    
    ["EasingStyle"] = Enum.EasingStyle.Exponential, -- Controls how the aim moves (smooth, bouncy, etc.)
    -- Available Styles: Linear, Quad, Cubic, Quart, Quint, Sine, Back, Bounce, Elastic (See link above)

    ["AirShot"] = true, -- If true, adjust smoothness when in the air
    ["AirShotSmooth"] = 0.021, -- How smooth the camera will move when you are in the air

    ["EasingDirection"] = Enum.EasingDirection.InOut, -- Decides how the easing applies
    -- In = Starts slow, speeds up | Out = Starts fast, slows down | InOut = Both combined

    --// FOV (Field of View) Settings
    ["FOV"] = {
        ["Visible"] = true, -- Show or hide the FOV circle
        ["Thickness"] = 0.5, -- Thickness of the FOV circle
        ["NumSides"] = 35, -- Makes the FOV circle smoother
        ["Radius"] = 100, -- Size of the FOV circle
        ["Filled"] = false, -- If true, FOV circle is filled inside
        ["Transparency"] = 0.2, -- How see-through the FOV circle is
        ["Color"] = Color3.fromRGB(173, 217, 230), -- Color of the FOV circle
        ["Mode"] = "PC" -- Use "PC" for computer, "Mobile" for mobile
    },

    --// SafetyChecks
    ["SafetyChecks"] = {
        ["Resolver"] = true,
        ["DetectionValue"] = 50, -- How strong detection needs to be
        ["OverrideYAxis"] = true, -- Will override the Y axis (very legit!)
    }
}

--// Services
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local Mouse = game.Players.LocalPlayer:GetMouse()
local Client = game.Players.LocalPlayer

--// Variables
local Target = nil
local IsCamlockActive = false

--// Create FOV Circle
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = Camlock["FOV"]["Visible"]
FOVCircle.Radius = Camlock["FOV"]["Radius"]
FOVCircle.Filled = Camlock["FOV"]["Filled"]
FOVCircle.Transparency = Camlock["FOV"]["Transparency"]
FOVCircle.Color = Camlock["FOV"]["Color"]
FOVCircle.NumSides = Camlock["FOV"]["NumSides"]
FOVCircle.Thickness = Camlock["FOV"]["Thickness"]

--// Update FOV Position
RunService.RenderStepped:Connect(function()
    if Camlock["FOV"]["Mode"] == "PC" then
        FOVCircle.Position = Vector2.new(Mouse.X, Mouse.Y)
    else
        FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    end
end)

--// Closest To Mouse
local function getClosestTarget()
    local closest, shortestDistance = nil, math.huge
    for _, v in ipairs(Players:GetPlayers()) do
        if v ~= Client and v.Character and v.Character:FindFirstChild(Camlock["AimPart"]) then
            local part = v.Character[Camlock["AimPart"]]
            local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
            if onScreen then
                local distance = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                if distance < shortestDistance then
                    closest, shortestDistance = v, distance
                end
            end
        end
    end
    return closest
end

--// Input Listener
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if input.KeyCode == Camlock["Keybind"] and not gameProcessedEvent then
        if IsCamlockActive then
            Target = nil
            IsCamlockActive = false
        else
            Target = getClosestTarget()
            IsCamlockActive = true
        end
    end
end)

--// Override Y-Axis (Safety Checks)
local function overrideYAxis(predictedPosition, Target)
    if Camlock["SafetyChecks"]["OverrideYAxis"] then
        -- Ensure the target and its character exist
        if Target and Target.Character then
            -- Prevent jumping movements, lock Y-axis to a certain value
            predictedPosition = Vector3.new(predictedPosition.X, Target.Character[Camlock["AimPart"]].Position.Y, predictedPosition.Z)
        end
    end
    return predictedPosition
end

--// AirShot Check
local function handleAirShot(Target, predictedPosition)
    if Camlock["AirShot"] then
        -- Check if the character is in the air
        if Target.Character and Target.Character:FindFirstChild("Humanoid") then
            local humanoid = Target.Character.Humanoid
            if humanoid:GetState() == Enum.HumanoidStateType.Physics then
                -- Apply AirShotSmooth value if in the air
                predictedPosition = predictedPosition:Lerp(predictedPosition + Vector3.new(0, 0.05, 0), Camlock["AirShotSmooth"])
            end
        end
    end
    return predictedPosition
end

--// Render Loop
RunService.Heartbeat:Connect(function()
    if Camlock["Enable"] and IsCamlockActive and Target then
        local part = Target.Character and Target.Character:FindFirstChild(Camlock["AimPart"])
        if part then
            local predictedPosition = part.Position + (Target.Character.HumanoidRootPart.Velocity * Camlock["Prediction"])
            predictedPosition = handleAirShot(Target, predictedPosition)  -- Handle AirShot logic
            predictedPosition = overrideYAxis(predictedPosition, Target)  -- Override Y-Axis if enabled

            local targetPosition = Vector3.new(predictedPosition.X, predictedPosition.Y, predictedPosition.Z)
            local targetCFrame = CFrame.new(Camera.CFrame.Position, targetPosition)

            -- Apply smoothness if enabled
            if Camlock["UseSmoothness"] then
                Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, Camlock["SmoothnessValue"], Camlock["EasingStyle"], Camlock["EasingDirection"])
            else
                Camera.CFrame = targetCFrame
            end
        end
    end
end)
